<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halloween Trivia Showdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/a57004f25b.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff6600; /* Orange */
            --secondary-color: #800080; /* Purple */
            --background-color: #1a1a1a; /* Dark background */
            --text-color: #ffffff; /* White text */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
        }
        h1, h2 {
            font-family: 'Creepster', cursive;
        }
        .text-creepy-orange { color: var(--primary-color); }
        .bg-creepy-orange { background-color: var(--primary-color); }
        .text-creepy-purple { color: var(--secondary-color); }
        .bg-creepy-purple { background-color: var(--secondary-color); }
        
        .card {
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary-color);
        }

        .btn-game {
            transition: all 0.1s ease;
            box-shadow: 0 4px 0 var(--secondary-color);
            border: 1px solid var(--secondary-color);
        }
        .btn-game:hover {
            box-shadow: 0 6px 0 var(--secondary-color);
            transform: translateY(-2px);
        }
        .btn-game:active {
            box-shadow: 0 0 0 var(--secondary-color);
            transform: translateY(4px);
        }

        .btn-answer {
            transition: all 0.1s ease;
            transform: scale(1);
            border: 2px solid transparent;
        }
        .btn-answer:hover {
            transform: scale(1.02);
            border: 2px solid var(--primary-color);
        }
        .btn-answer.selected {
            border-color: #4ade80; /* Green */
            box-shadow: 0 0 10px #4ade80;
        }
        .btn-answer.correct {
            background-color: #10b981 !important; /* Tailwind green-500 */
        }
        .btn-answer.incorrect {
            background-color: #ef4444 !important; /* Tailwind red-500 */
        }
    </style>
</head>
<body>

    <!-- Main Application Container -->
    <div id="app" class="flex flex-col items-center p-4 sm:p-8">
        <!-- UPDATED TITLE TO BE SOLID ORANGE -->
        <h1 class="text-6xl sm:text-7xl font-bold mb-4 text-creepy-orange tracking-widest text-center">
            Halloween Trivia
        </h1>

        <!-- Content will be rendered here based on state (Lobby, Game, Scoreboard) -->
        <div id="game-content" class="w-full max-w-4xl">
            <!-- Loading/Error State Placeholder -->
            <div id="loading-state" class="card p-6 text-center">
                <i class="fas fa-ghost fa-spin text-4xl text-creepy-orange mb-4"></i>
                <p class="text-xl">Loading Crypt...</p>
            </div>
        </div>

        <!-- System Message Box -->
        <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 card p-3 opacity-0 transition-opacity duration-300 pointer-events-none z-50">
            <p id="message-text" class="text-sm"></p>
        </div>

        <!-- TV/Display Mode Button -->
        <button id="tv-mode-btn" class="fixed top-4 right-4 bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-full transition duration-150 shadow-lg text-xs z-50">
            TV Display Mode
        </button>
    </div>

    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // Imports updated for clean usage (removed unused and confirmed 'getDocs' is present)
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, query, runTransaction, updateDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =========================================================================
        // --- Firebase Config and Initialization (Hardcoded for deployment) ---
        // The configuration is now hardcoded below. If you change your Firebase
        // project, you MUST update this section.
        const firebaseConfig = {
            apiKey: "AIzaSyD2qmDEWrqKERcEQf36THyzYb3ip8TLQf4",
            authDomain: "minturntrivia.firebaseapp.com",
            projectId: "minturntrivia",
            storageBucket: "minturntrivia.firebasestorage.app",
            messagingSenderId: "465699900511",
            appId: "1:465699900511:web:a1b7019bc82a5407881fea",
            measurementId: "G-VEX4W50GEE"
        };
        
        // Hardcoded application ID for Firestore pathing: /artifacts/{appId}/public/data/
        const appId = 'minturntrivia-app';
        
        // The auth token is handled by the canvas environment or falls back to an undefined value.
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : undefined;

        // Global Firebase instances and user state
        let app;
        let db;
        let auth;
        let userId;
        let userData; // Stores the current user's profile (name, color, score)

        const APP_COLLECTION = `artifacts/${appId}/public/data/game-state`;
        const PLAYERS_COLLECTION = `artifacts/${appId}/public/data/players`;
        const GAME_DOC_ID = 'main-game';
        
        // Local state
        let gameState = {
            status: 'loading', // 'loading', 'lobby', 'in_progress', 'scoring', 'finished'
            currentQuestion: null, // index of question
            questions: [],
            hostId: null,
            timer: 0,
            questionStartTime: 0,
            players: {},
            lastAnswer: null, // Stores {answer: 'A', timestamp: 123}
            correctAnswer: null,
        };

        const TV_MODE_DELAY = 1000; // Delay for TV mode state transitions

        // Utility: Show a temporary message
        function showMessage(text, isError = false) {
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');

            messageText.textContent = text;
            messageBox.style.backgroundColor = isError ? '#ef4444' : '#1f2937'; // Red for error, dark gray otherwise
            messageBox.style.opacity = '1';
            
            setTimeout(() => {
                messageBox.style.opacity = '0';
            }, 3000);
        }

        // Utility: Generate player ID if not authenticated (shouldn't happen with anonymous auth, but as fallback)
        function generateTemporaryId() {
            return 'temp-' + Math.random().toString(36).substring(2, 9);
        }
        
        // Utility: Base64 to ArrayBuffer for playing audio
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Utility: Convert PCM to WAV format
        function pcmToWav(pcm16, sampleRate = 24000) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const dataLength = pcm16.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            
            // FMT sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Sub-chunk size: 16
            view.setUint16(20, 1, true); // Audio format (1 for PCM)
            view.setUint16(22, numChannels, true); // Number of channels
            view.setUint32(24, sampleRate, true); // Sample rate
            view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true); // Byte rate
            view.setUint16(32, numChannels * (bitsPerSample / 8), true); // Block align
            view.setUint16(34, bitsPerSample, true); // Bits per sample
            
            // DATA sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        // Utility: Helper for writing string to DataView
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // Utility: Play audio from a text prompt
        async function playTTS(text) {
            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Fenrir" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            try {
                // Implementing exponential backoff for API call
                const maxRetries = 3;
                let attempt = 0;
                let response;

                while (attempt < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) break;

                        if (response.status === 429) {
                            // Too Many Requests, implement backoff
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            // Non-retryable error
                            throw new Error(`API returned status ${response.status}`);
                        }
                    } catch (error) {
                        // Network error or other fetch-related issues
                        if (attempt === maxRetries - 1) throw error;
                    }
                    attempt++;
                }
                
                if (!response || !response.ok) throw new Error("TTS API call failed after retries.");

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    // API returns signed PCM16 audio data.
                    const pcm16 = new Int16Array(pcmData);
                    
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();
                } else {
                    console.error("TTS response missing audio data or invalid mime type.");
                }

            } catch (error) {
                console.error("Error generating or playing TTS:", error);
            }
        }

        // =========================================================================
        // --- Game Logic Functions (Shared) ---
        // =========================================================================
        
        async function fetchQuestions() {
            // NOTE: The `trivia.json.txt` file is accessible in the environment.
            try {
                const response = await fetch('trivia.json.txt');
                if (!response.ok) throw new Error("Trivia file not found.");
                const data = await response.json();
                return data;
            } catch (e) {
                console.error("Failed to load trivia questions:", e);
                // Fallback dummy data if file access fails
                return [
                    { category: "Test", question: "What color is a ghost?", options: { "A": "White", "B": "Black", "C": "Orange", "D": "Purple" }, answer: "A" },
                    { category: "Test", question: "What is 1 + 1?", options: { "A": "1", "B": "2", "C": "3", "D": "4" }, answer: "B" },
                    { category: "Test", question: "The Blair Witch Project was released in...", options: { "A": "1997", "B": "1999", "C": "2001", "D": "2003" }, answer: "B" },
                ];
            }
        }

        /**
         * Initializes the game state in Firestore if it doesn't exist.
         */
        async function initializeGameData() {
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            const gameDoc = await getDoc(gameDocRef);

            if (!gameDoc.exists()) {
                const questions = await fetchQuestions();
                
                // Shuffle questions
                for (let i = questions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [questions[i], questions[j]] = [questions[j], questions[i]];
                }

                const initialData = {
                    status: 'lobby',
                    currentQuestion: -1, // -1 means no question is active (lobby/finished)
                    totalQuestions: questions.length,
                    questions: questions,
                    hostId: userId, // Current user is the host
                    timer: 0,
                    questionStartTime: 0,
                    players: {}, // Managed separately by the player listener
                    lastUpdateTime: Date.now(),
                    correctAnswer: null, // 'A', 'B', 'C', 'D'
                    showScoreboard: false, // Flag to show mid-game scoreboard on TV
                };
                await setDoc(gameDocRef, initialData);
            }
        }

        /**
         * Attempts to join the game by setting up the user's profile.
         */
        async function joinGame(name, color) {
            if (!userId) {
                showMessage("Authentication failed. Cannot join game.", true);
                return;
            }
            
            const playerDocRef = doc(db, PLAYERS_COLLECTION, userId);
            const playerDoc = await getDoc(playerDocRef);

            if (playerDoc.exists()) {
                showMessage("You are already in the game.", false);
                return;
            }

            try {
                await setDoc(playerDocRef, {
                    id: userId,
                    name: name,
                    color: color,
                    score: 0,
                    isHost: gameState.hostId === userId,
                    lastAnswer: null, // {questionIndex: 0, answer: 'A', timeTaken: 500}
                    joinedAt: Date.now(),
                });
                showMessage(`Welcome, ${name}!`);
            } catch (e) {
                console.error("Error joining game: ", e);
                showMessage("Failed to join game.", true);
            }
        }

        /**
         * Host-only function to start the game.
         */
        async function startGame() {
            if (gameState.hostId !== userId) {
                showMessage("Only the host can start the game.", true);
                return;
            }
            if (Object.keys(gameState.players).length < 1) {
                showMessage("You need at least one player to start.", true);
                return;
            }

            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            try {
                await updateDoc(gameDocRef, {
                    status: 'in_progress',
                    currentQuestion: 0,
                    questionStartTime: Date.now(),
                    timer: 15, // Initial timer for the first question
                    lastUpdateTime: Date.now(),
                    showScoreboard: false,
                });
                showMessage("Game started!");
                playTTS("Game has started! Question number one is coming up!");
            } catch (e) {
                console.error("Error starting game: ", e);
                showMessage("Failed to start game.", true);
            }
        }
        
        /**
         * Host-only function to advance to the next question or the final scoreboard.
         */
        async function nextQuestion() {
            if (gameState.hostId !== userId) {
                showMessage("Only the host can advance.", true);
                return;
            }

            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            const nextIndex = gameState.currentQuestion + 1;
            
            // If the game is in scoring state, we move to the next question (or finish)
            if (gameState.status === 'scoring') {
                if (nextIndex < gameState.totalQuestions) {
                    // Start next question
                    try {
                        await updateDoc(gameDocRef, {
                            status: 'in_progress',
                            currentQuestion: nextIndex,
                            questionStartTime: Date.now(),
                            timer: 15, // Reset timer
                            lastUpdateTime: Date.now(),
                            correctAnswer: null,
                            showScoreboard: false,
                        });
                        const questionNumber = nextIndex + 1;
                        playTTS(`Question number ${questionNumber}`);
                        showMessage(`Starting Question ${questionNumber}.`);
                    } catch (e) {
                        console.error("Error advancing question: ", e);
                        showMessage("Failed to advance question.", true);
                    }
                } else {
                    // End game
                    try {
                        await updateDoc(gameDocRef, {
                            status: 'finished',
                            currentQuestion: -1,
                            lastUpdateTime: Date.now(),
                            correctAnswer: null,
                            showScoreboard: true,
                        });
                        playTTS("The final question is complete. The game is over! Let's see the final scores.");
                        showMessage("Game finished. Showing final scoreboard.");
                    } catch (e) {
                        console.error("Error finishing game: ", e);
                        showMessage("Failed to finish game.", true);
                    }
                }
            } else if (gameState.status === 'in_progress' || gameState.status === 'lobby') {
                // If it's still in progress, the host clicks to reveal the answer.
                revealAnswer();
            }
        }

        /**
         * Host-only function to reveal the answer and initiate scoring.
         */
        async function revealAnswer() {
            if (gameState.hostId !== userId) {
                showMessage("Only the host can reveal the answer.", true);
                return;
            }
            if (gameState.status !== 'in_progress') return;

            const currentQ = gameState.questions[gameState.currentQuestion];
            const correctKey = currentQ.answer;

            // 1. Update Game State to reveal answer
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            await updateDoc(gameDocRef, {
                status: 'scoring',
                correctAnswer: correctKey,
                lastUpdateTime: Date.now(),
            });
            playTTS(`The correct answer is ${correctKey}`);
            
            showMessage(`Answer revealed: ${correctKey}. Calculating scores...`);

            // 2. Score calculation using a Transaction (ensures atomicity)
            const playerDocsQuery = query(collection(db, PLAYERS_COLLECTION));
            const playerDocsSnapshot = await getDocs(playerDocsQuery); // getDocs is imported now

            for (const playerDoc of playerDocsSnapshot.docs) {
                const playerId = playerDoc.id;
                const playerDocRef = doc(db, PLAYERS_COLLECTION, playerId);
                const playerAnswer = gameState.players[playerId]?.lastAnswer;
                
                // Only process answers for the current question
                if (playerAnswer && playerAnswer.questionIndex === gameState.currentQuestion) {
                    await runTransaction(db, async (transaction) => {
                        const freshDoc = await transaction.get(playerDocRef);
                        if (!freshDoc.exists()) return;

                        let currentScore = freshDoc.data().score || 0;
                        let scoreDelta = 0;

                        if (playerAnswer.answer === correctKey) {
                            // Max points: 1000. Time is from 0ms to 15000ms.
                            // Fast answers get more points.
                            const maxTime = gameState.timer * 1000;
                            const timeRatio = Math.max(0, 1 - (playerAnswer.timeTaken / maxTime));
                            scoreDelta = 500 + Math.round(timeRatio * 500); // 500 base + up to 500 bonus
                        }

                        if (scoreDelta > 0) {
                            transaction.update(playerDocRef, {
                                score: currentScore + scoreDelta,
                                lastAnswer: {...playerAnswer, pointsAwarded: scoreDelta},
                            });
                        } else {
                            // Clear lastAnswer if incorrect to stop score calculation on re-clicks
                            transaction.update(playerDocRef, {
                                lastAnswer: {...playerAnswer, pointsAwarded: 0},
                            });
                        }
                    });
                }
            }
        }

        /**
         * Player function to submit an answer.
         */
        async function submitAnswer(answerKey) {
            if (gameState.status !== 'in_progress' || !userData) return;
            
            const timeElapsed = Date.now() - gameState.questionStartTime;

            // Prevent answering after the timer runs out (or after the 15-second window)
            if (timeElapsed > gameState.timer * 1000) {
                 showMessage("Time's up! Cannot submit an answer.", true);
                 return;
            }

            // Check if player has already answered this question
            const existingAnswer = userData.lastAnswer;
            if (existingAnswer && existingAnswer.questionIndex === gameState.currentQuestion) {
                // Allow player to change their mind, but update the time taken
            }

            const playerDocRef = doc(db, PLAYERS_COLLECTION, userId);
            try {
                await updateDoc(playerDocRef, {
                    lastAnswer: {
                        questionIndex: gameState.currentQuestion,
                        answer: answerKey,
                        timeTaken: timeElapsed,
                    },
                    lastUpdateTime: Date.now(),
                });
                showMessage(`Submitted answer ${answerKey}.`);
            } catch (e) {
                console.error("Error submitting answer: ", e);
                showMessage("Failed to submit answer.", true);
            }
        }
        
        /**
         * Host-only function to show the scoreboard mid-game.
         */
        async function toggleScoreboard() {
            if (gameState.hostId !== userId) {
                showMessage("Only the host can toggle the scoreboard.", true);
                return;
            }
            if (gameState.status !== 'scoring') {
                showMessage("Scoreboard can only be shown after an answer is revealed.", true);
                return;
            }
            
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            try {
                await updateDoc(gameDocRef, {
                    showScoreboard: !gameState.showScoreboard,
                });
                showMessage(gameState.showScoreboard ? "Scoreboard hidden." : "Scoreboard shown.");
            } catch (e) {
                console.error("Error toggling scoreboard: ", e);
                showMessage("Failed to toggle scoreboard.", true);
            }
        }
        
        // =========================================================================
        // --- Rendering and View Management ---
        // =========================================================================

        const gameContent = document.getElementById('game-content');
        const tvModeBtn = document.getElementById('tv-mode-btn');
        const isTVMode = window.location.search.includes('view=tv');

        if (isTVMode) {
            tvModeBtn.textContent = 'Player Mode';
            tvModeBtn.onclick = () => window.location.href = window.location.pathname;
        } else {
            tvModeBtn.textContent = 'TV Display Mode';
            tvModeBtn.onclick = () => window.location.href = window.location.pathname + '?view=tv';
        }

        function render() {
            // Determine the current view state
            let view = 'loading';
            if (!userId) {
                view = 'loading'; // Wait for auth
            } else if (!userData && gameState.status === 'lobby') {
                view = 'join';
            } else if (gameState.status === 'lobby') {
                view = 'lobby';
            } else if (gameState.status === 'in_progress') {
                view = 'question';
            } else if (gameState.status === 'scoring') {
                view = 'scoring';
            } else if (gameState.status === 'finished') {
                view = 'scoreboard';
            }

            // Apply TV mode override
            if (isTVMode) {
                if (view === 'join' || view === 'lobby') {
                    // TV shows the lobby (QR code) in both cases
                    renderLobbyTV();
                } else if (view === 'question' || view === 'scoring' || view === 'finished') {
                    // Show game/scoring/final screen
                    renderGameTV();
                } else {
                    gameContent.innerHTML = `<div class="card p-6 text-center text-2xl">Awaiting Host Initialization...</div>`;
                }
                return;
            }

            // --- Player View Rendering ---
            
            switch (view) {
                case 'loading':
                    gameContent.innerHTML = `<div class="card p-6 text-center">
                        <i class="fas fa-spinner fa-spin text-4xl text-creepy-orange mb-4"></i>
                        <p class="text-xl">Checking for ghosts...</p>
                    </div>`;
                    break;
                case 'join':
                    renderJoinForm();
                    break;
                case 'lobby':
                    renderLobbyPlayer();
                    break;
                case 'question':
                    renderQuestionPlayer();
                    break;
                case 'scoring':
                    renderScoringPlayer();
                    break;
                case 'scoreboard':
                    renderScoreboardPlayer();
                    break;
                default:
                    gameContent.innerHTML = `<div class="card p-6 text-center text-xl text-red-500">
                        <i class="fas fa-exclamation-triangle mr-2"></i>Game State Error.
                    </div>`;
            }
        }
        
        // --- Player Rendering Functions ---

        function renderJoinForm() {
            let colors = ['#e91e63', '#9c27b0', '#2196f3', '#009688', '#ff9800', '#f44336'];
            let selectedColor = colors[0];

            function colorSelectorHTML() {
                return colors.map(c => `
                    <button type="button" data-color="${c}" style="background-color: ${c};" 
                        class="color-btn w-10 h-10 rounded-full mx-1 shadow-lg border-2 ${c === selectedColor ? 'border-white ring-2 ring-creepy-orange' : 'border-gray-500'}"
                        onclick="selectColor('${c}')"></button>
                `).join('');
            }
            
            // Expose selectColor to global scope temporarily for inline click handler
            window.selectColor = (c) => {
                selectedColor = c;
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.remove('border-white', 'ring-2', 'ring-creepy-orange');
                    if (btn.dataset.color === c) {
                        btn.classList.add('border-white', 'ring-2', 'ring-creepy-orange');
                    }
                });
            };

            const html = `
                <div class="card p-8 w-full max-w-md mx-auto mt-10">
                    <h2 class="text-3xl text-creepy-orange mb-6 text-center">Join the Fray</h2>
                    <form id="join-form" class="space-y-4">
                        <div>
                            <label for="player-name" class="block text-sm font-semibold mb-1">Your Spooky Nickname:</label>
                            <input type="text" id="player-name" placeholder="Enter your name" required 
                                class="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:border-creepy-orange focus:ring-1 focus:ring-creepy-orange">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold mb-2">Pick Your Color:</label>
                            <div class="flex justify-center" id="color-picker-container">
                                ${colorSelectorHTML()}
                            </div>
                        </div>
                        <button type="submit" 
                            class="w-full p-3 mt-6 bg-creepy-orange hover:bg-opacity-90 text-white font-extrabold rounded-lg text-lg btn-game">
                            Enter Game
                        </button>
                    </form>
                </div>
            `;
            gameContent.innerHTML = html;
            
            document.getElementById('join-form').onsubmit = (e) => {
                e.preventDefault();
                const name = document.getElementById('player-name').value.trim();
                if (name) {
                    joinGame(name, selectedColor);
                }
            };
        }

        function renderLobbyPlayer() {
            const isHost = gameState.hostId === userId;
            const playerCount = Object.keys(gameState.players).length;
            const playersList = Object.values(gameState.players)
                .map(p => `
                    <li class="flex justify-between items-center p-3 rounded-lg bg-gray-700/50 my-2 shadow">
                        <span class="text-lg font-semibold" style="color:${p.color};">${p.name}</span>
                        ${p.isHost ? '<span class="text-xs text-creepy-orange font-bold">HOST <i class="fas fa-crown"></i></span>' : ''}
                    </li>
                `).join('');

            const html = `
                <div class="card p-8 w-full max-w-xl mx-auto mt-10 text-center">
                    <h2 class="text-4xl text-creepy-purple mb-4">Lobby Waiting...</h2>
                    <p class="mb-6 text-gray-400">Welcome, <span style="color:${userData?.color || '#fff'}; font-weight:bold;">${userData?.name || 'Player'}</span>!</p>
                    
                    ${isHost ? `
                        <div class="mb-8">
                            <button onclick="startGame()" 
                                class="w-full p-4 bg-green-500 hover:bg-green-600 text-white font-extrabold rounded-lg text-xl btn-game shadow-green-700/50">
                                Start Game (${playerCount} Players)
                            </button>
                            <p class="text-sm text-gray-400 mt-2">The TV screen has the QR code for others to join.</p>
                        </div>
                    ` : `
                        <div class="mb-8">
                            <p class="text-xl text-gray-300 animate-pulse">Waiting for the Host to start...</p>
                        </div>
                    `}
                    
                    <h3 class="text-xl text-creepy-orange font-bold mb-3">Players Joined:</h3>
                    <ul class="text-left max-h-64 overflow-y-auto">
                        ${playersList || '<li class="text-center text-gray-500 p-4">No other players have joined yet.</li>'}
                    </ul>
                </div>
            `;
            gameContent.innerHTML = html;
            window.startGame = startGame;
        }

        function renderQuestionPlayer() {
            const questionIndex = gameState.currentQuestion;
            const currentQ = gameState.questions[questionIndex];
            if (!currentQ) {
                 gameContent.innerHTML = `<div class="card p-6 text-center text-xl text-red-500">Question not found.</div>`;
                 return;
            }

            const isAnswered = userData?.lastAnswer?.questionIndex === questionIndex;
            const answeredKey = isAnswered ? userData.lastAnswer.answer : null;
            
            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                let classes = 'p-4 rounded-xl text-lg font-bold w-full text-left transition-colors duration-100 bg-gray-700 hover:bg-gray-600 btn-answer';
                if (answeredKey === key) {
                    classes += ' selected ring-4 ring-creepy-orange';
                }
                
                return `
                    <button onclick="submitAnswer('${key}')" ${isAnswered ? 'disabled' : ''}
                        class="${classes}">
                        <span class="inline-block w-6 h-6 text-center bg-creepy-orange text-black rounded-full mr-3">${key}</span>
                        ${value}
                    </button>
                `;
            }).join('');

            const html = `
                <div class="card p-6 mt-4">
                    <p class="text-sm text-creepy-purple mb-1 font-semibold">Category: ${currentQ.category}</p>
                    <h2 class="text-3xl sm:text-4xl font-extrabold mb-6">${currentQ.question}</h2>
                    
                    <div id="answer-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${optionsHTML}
                    </div>
                    
                    <div class="mt-6 text-center">
                        <p class="text-lg text-gray-400">
                            ${isAnswered ? 
                                `<span class="text-green-400 font-bold"><i class="fas fa-check-circle mr-2"></i>Answer submitted!</span> Waiting for Host...` : 
                                'Select your final answer quickly!'}
                        </p>
                    </div>
                </div>
            `;
            gameContent.innerHTML = html;
            window.submitAnswer = submitAnswer;
        }

        function renderScoringPlayer() {
            const questionIndex = gameState.currentQuestion;
            const currentQ = gameState.questions[questionIndex];
            const correctKey = gameState.correctAnswer;
            const playerAnswer = userData?.lastAnswer;
            const answeredKey = playerAnswer?.questionIndex === questionIndex ? playerAnswer.answer : null;
            const isCorrect = answeredKey === correctKey;
            const points = playerAnswer?.pointsAwarded || 0;

            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                let classes = 'p-4 rounded-xl text-lg font-bold w-full text-left opacity-60';
                
                if (key === correctKey) {
                    classes += ' correct bg-green-500 opacity-100 ring-4 ring-green-300';
                } else if (key === answeredKey && !isCorrect) {
                    classes += ' incorrect bg-red-500 opacity-100 ring-4 ring-red-300';
                } else {
                    classes += ' bg-gray-700';
                }
                
                return `
                    <div class="${classes}">
                        <span class="inline-block w-6 h-6 text-center ${key === correctKey ? 'bg-white text-green-500' : 'bg-creepy-orange text-black'} rounded-full mr-3">${key}</span>
                        ${value}
                        ${key === correctKey ? '<span class="float-right text-xs font-normal bg-white text-green-500 px-2 py-1 rounded-full">CORRECT</span>' : ''}
                        ${key === answeredKey && !isCorrect ? '<span class="float-right text-xs font-normal bg-white text-red-500 px-2 py-1 rounded-full">YOUR ANSWER</span>' : ''}
                    </div>
                `;
            }).join('');
            
            const feedbackTitle = isCorrect ? 
                `<h3 class="text-3xl text-green-400 font-extrabold"><i class="fas fa-magic mr-2"></i>CORRECT! +${points} Points!</h3>` :
                `<h3 class="text-3xl text-red-400 font-extrabold"><i class="fas fa-skull-crossbones mr-2"></i>INCORRECT.</h3>`;

            const html = `
                <div class="card p-6 mt-4 text-center">
                    <p class="text-sm text-creepy-purple mb-1 font-semibold">Question ${questionIndex + 1} of ${gameState.totalQuestions}</p>
                    <h2 class="text-3xl sm:text-4xl font-extrabold mb-6">${currentQ.question}</h2>
                    
                    <div class="mb-8 p-4 rounded-xl shadow-inner ${isCorrect ? 'bg-green-900/40' : 'bg-red-900/40'}">
                        ${feedbackTitle}
                        <p class="text-lg mt-2">Your current score: <span class="font-bold text-creepy-orange">${userData?.score || 0}</span></p>
                    </div>

                    <div id="answer-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${optionsHTML}
                    </div>
                    
                    <p class="mt-6 text-lg text-gray-400">Waiting for the Host to proceed...</p>
                    
                    ${gameState.hostId === userId ? `
                        <button onclick="nextQuestion()" 
                            class="w-full p-4 mt-6 bg-creepy-orange hover:bg-opacity-90 text-white font-extrabold rounded-lg text-xl btn-game">
                            ${questionIndex < gameState.totalQuestions - 1 ? 'NEXT QUESTION' : 'END GAME / FINAL SCOREBOARD'}
                        </button>
                    ` : ''}
                </div>
            `;
            gameContent.innerHTML = html;
            window.nextQuestion = nextQuestion;
        }
        
        function renderScoreboardPlayer() {
             const sortedPlayers = Object.values(gameState.players).sort((a, b) => b.score - a.score);
             const isFinal = gameState.status === 'finished';

             const playerRankings = sortedPlayers.map((p, index) => {
                 let medalIcon = '';
                 if (index === 0) medalIcon = '<i class="fas fa-trophy text-yellow-500"></i>';
                 if (index === 1) medalIcon = '<i class="fas fa-medal text-gray-400"></i>';
                 if (index === 2) medalIcon = '<i class="fas fa-medal text-yellow-700"></i>';

                 const highlightClass = p.id === userId ? 'ring-4 ring-creepy-orange bg-gray-600/50' : 'bg-gray-700/50';

                 return `
                    <li class="flex justify-between items-center p-4 rounded-xl my-2 shadow-xl ${highlightClass}">
                        <div class="flex items-center space-x-3">
                            <span class="text-2xl font-black w-8 text-center">${index + 1}</span>
                            <span class="text-3xl mr-2" style="color:${p.color};">${medalIcon}</span>
                            <span class="text-xl font-bold" style="color:${p.color};">${p.name}</span>
                        </div>
                        <span class="text-2xl font-extrabold text-creepy-orange">${p.score} <span class="text-sm font-normal text-gray-400">PTS</span></span>
                    </li>
                 `;
             }).join('');
             
            const html = `
                <div class="card p-8 w-full max-w-xl mx-auto mt-4 text-center">
                    <h2 class="text-5xl ${isFinal ? 'text-creepy-orange' : 'text-creepy-purple'} mb-4">${isFinal ? 'Final Scoreboard' : 'Current Scores'}</h2>
                    ${isFinal && sortedPlayers.length > 0 ? 
                        `<p class="text-2xl text-yellow-500 font-extrabold mb-6">🏆 ${sortedPlayers[0].name} Wins! 🏆</p>` : ''}
                    
                    <ul class="text-left max-h-[80vh] overflow-y-auto">
                        ${playerRankings || '<li class="text-center text-gray-500 p-4">No players to score yet.</li>'}
                    </ul>
                    
                    ${gameState.hostId === userId && gameState.status === 'finished' ? `
                        <p class="mt-8 text-sm text-gray-400">The game is over. To start a new game, refresh the page to re-initialize the data.</p>
                    ` : ''}
                </div>
            `;
            gameContent.innerHTML = html;
        }
        
        // --- TV Rendering Functions ---

        function renderLobbyTV() {
            const playerCount = Object.keys(gameState.players).length;
            const playersList = Object.values(gameState.players)
                .map(p => `
                    <li class="p-3 text-lg font-semibold rounded-lg bg-gray-700/50 my-1 shadow" style="color:${p.color};">
                        ${p.name}
                    </li>
                `).join('');
                
            const appUrl = window.location.origin + window.location.pathname;

            const html = `
                <div class="card p-10 w-full mx-auto mt-4 text-center">
                    <h2 class="text-6xl text-creepy-orange mb-6">Join the Game!</h2>
                    
                    <!-- Placeholder for QR Code (Requires external service or manual generation) -->
                    <div class="bg-white p-4 inline-block rounded-xl shadow-2xl">
                        <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(appUrl)}" alt="QR Code" class="w-48 h-48"/>
                    </div>
                    
                    <p class="mt-4 text-xl text-gray-300 font-semibold">
                        Go to: <span class="text-creepy-purple font-mono">${appUrl}</span>
                    </p>
                    
                    <h3 class="text-3xl text-creepy-purple font-bold mt-8 mb-4">Players Joined (${playerCount}):</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 max-h-48 overflow-y-auto">
                        ${playersList || '<div class="col-span-4 text-gray-500 p-4">No players yet. Scan the code to join!</div>'}
                    </div>
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderGameTV() {
            const questionIndex = gameState.currentQuestion;
            const currentQ = gameState.questions[questionIndex];
            const isScoring = gameState.status === 'scoring';
            const isFinished = gameState.status === 'finished';
            const correctKey = gameState.correctAnswer;
            
            if (isFinished || gameState.showScoreboard) {
                renderScoreboardTV();
                return;
            }

            if (!currentQ) {
                 gameContent.innerHTML = `<div class="card p-6 text-center text-xl text-red-500">Error: Question not found.</div>`;
                 return;
            }
            
            // Player Answer Tally
            const answerTally = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
            let totalAnswered = 0;
            Object.values(gameState.players).forEach(p => {
                if (p.lastAnswer && p.lastAnswer.questionIndex === questionIndex) {
                    answerTally[p.lastAnswer.answer]++;
                    totalAnswered++;
                }
            });
            const playerCount = Object.keys(gameState.players).length;

            const timerDisplay = isScoring ? 
                `<span class="text-3xl text-creepy-orange"><i class="fas fa-check-circle"></i> ANSWER REVEALED</span>` : 
                `<span class="text-6xl font-extrabold text-creepy-orange">${gameState.timer}</span>`;

            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                const isCorrect = isScoring && key === correctKey;
                const backgroundColor = isCorrect ? 'bg-green-600' : 'bg-gray-700';
                const ringClass = isCorrect ? 'ring-4 ring-green-400' : '';
                const tallyCount = isScoring ? answerTally[key] : '';
                const tallyPercent = isScoring ? (tallyCount / totalAnswered * 100).toFixed(0) : '';

                return `
                    <div class="p-6 rounded-xl text-lg font-bold w-full text-left transition-colors duration-300 ${backgroundColor} ${ringClass}">
                        <div class="flex justify-between items-center mb-1">
                             <span class="inline-block w-8 h-8 text-center bg-creepy-orange text-black rounded-full mr-3 text-xl font-black">${key}</span>
                             <span class="text-lg font-semibold flex-grow">${value}</span>
                        </div>
                        ${isScoring ? `
                            <div class="mt-3 text-center">
                                <span class="text-2xl font-black text-white">${tallyCount}</span>
                                <span class="text-sm text-gray-300 ml-1">PLAYERS (${tallyPercent}%)</span>
                                ${isCorrect ? '<i class="fas fa-crown text-yellow-500 ml-2"></i>' : ''}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            const hostControls = gameState.hostId === userId ? `
                <div class="mt-8">
                    <button onclick="${isScoring ? 'toggleScoreboard()' : 'revealAnswer()'}" 
                        class="w-full p-4 bg-creepy-purple hover:bg-opacity-90 text-white font-extrabold rounded-lg text-xl btn-game shadow-creepy-orange">
                        ${isScoring ? 'SHOW SCOREBOARD' : 'REVEAL ANSWER & SCORE'}
                    </button>
                    ${isScoring ? `
                        <button onclick="nextQuestion()" 
                            class="w-full p-4 mt-3 bg-creepy-orange hover:bg-opacity-90 text-white font-extrabold rounded-lg text-xl btn-game shadow-creepy-purple">
                            ${questionIndex < gameState.totalQuestions - 1 ? 'NEXT QUESTION' : 'END GAME / FINAL SCOREBOARD'}
                        </button>
                    ` : ''}
                </div>
            ` : '';

            const html = `
                <div class="card p-10 mt-4">
                    <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-700">
                        <p class="text-2xl text-creepy-purple font-extrabold">Q${questionIndex + 1} / ${gameState.totalQuestions}</p>
                        ${timerDisplay}
                    </div>
                    
                    <h2 class="text-4xl sm:text-5xl font-extrabold mb-8 text-center">${currentQ.question}</h2>
                    
                    <div id="answer-options" class="grid grid-cols-2 gap-6">
                        ${optionsHTML}
                    </div>
                    
                    <div class="mt-6 text-center text-xl text-gray-400">
                        Players Answered: <span class="text-creepy-orange font-bold">${totalAnswered}/${playerCount}</span>
                    </div>

                    ${hostControls}
                </div>
            `;
            gameContent.innerHTML = html;
            window.revealAnswer = revealAnswer;
            window.nextQuestion = nextQuestion;
            window.toggleScoreboard = toggleScoreboard;
        }

        function renderScoreboardTV() {
             const sortedPlayers = Object.values(gameState.players).sort((a, b) => b.score - a.score);
             const isFinal = gameState.status === 'finished';

             const playerRankings = sortedPlayers.map((p, index) => {
                 let medalIcon = '';
                 if (index === 0) medalIcon = '<i class="fas fa-crown text-yellow-500"></i>';
                 if (index === 1) medalIcon = '<i class="fas fa-medal text-gray-400"></i>';
                 if (index === 2) medalIcon = '<i class="fas fa-medal text-yellow-700"></i>';

                 return `
                    <li class="flex justify-between items-center p-5 rounded-xl my-2 shadow-2xl bg-gray-700/50 hover:scale-[1.01] transition-transform duration-100">
                        <div class="flex items-center space-x-4">
                            <span class="text-4xl font-black w-10 text-creepy-orange text-center">${index + 1}</span>
                            <span class="text-4xl" style="color:${p.color};">${medalIcon}</span>
                            <span class="text-3xl font-bold" style="color:${p.color};">${p.name}</span>
                        </div>
                        <span class="text-4xl font-extrabold text-creepy-orange">${p.score} <span class="text-lg font-normal text-gray-400">PTS</span></span>
                    </li>
                 `;
             }).join('');
             
            const hostControls = gameState.hostId === userId && !isFinal ? `
                <div class="mt-8">
                    <button onclick="toggleScoreboard()" 
                        class="w-full p-4 bg-creepy-purple hover:bg-opacity-90 text-white font-extrabold rounded-lg text-xl btn-game shadow-creepy-orange">
                        HIDE SCOREBOARD / BACK TO QUESTION
                    </button>
                    <button onclick="nextQuestion()" 
                        class="w-full p-4 mt-3 bg-creepy-orange hover:bg-opacity-90 text-white font-extrabold rounded-lg text-xl btn-game shadow-creepy-purple">
                        ${gameState.currentQuestion < gameState.totalQuestions - 1 ? 'NEXT QUESTION' : 'END GAME / FINAL SCOREBOARD'}
                    </button>
                </div>
            ` : '';
            
            const html = `
                <div class="card p-10 w-full mx-auto mt-4 text-center">
                    <h2 class="text-7xl ${isFinal ? 'text-creepy-orange' : 'text-creepy-purple'} mb-4">${isFinal ? 'FINAL SCOREBOARD' : 'LEADERBOARD'}</h2>
                    ${isFinal && sortedPlayers.length > 0 ? 
                        `<p class="text-3xl text-yellow-500 font-extrabold mb-8">🏆 THE WINNER IS ${sortedPlayers[0].name.toUpperCase()}! 🏆</p>` : ''}
                    
                    <ul class="text-left max-h-[70vh] overflow-y-auto">
                        ${playerRankings || '<li class="text-center text-gray-500 p-4">No scores to display.</li>'}
                    </ul>
                    
                    ${hostControls}
                </div>
            `;
            gameContent.innerHTML = html;
            window.toggleScoreboard = toggleScoreboard;
            window.nextQuestion = nextQuestion;
        }


        // =========================================================================
        // --- Firebase Listeners and Setup ---
        // =========================================================================

        function setupListeners() {
            // 1. Game State Listener
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    gameState = { ...gameState, ...docSnap.data() };
                    // Handle Host Assignment if needed (first joiner if hostId is null)
                    if (gameState.hostId === null && userId) {
                         // Only the first player to join will execute this (handled by transaction)
                        updateDoc(gameDocRef, { hostId: userId, lastUpdateTime: Date.now() })
                            .catch(e => console.log("Host already set or initial update error:", e));
                    }
                } else {
                    // Game doc does not exist, initialize it (only possible if user is authenticated)
                    if (userId) {
                        initializeGameData().catch(e => console.error("Failed to initialize game:", e));
                    }
                }
            });
            
            // 2. All Players Listener (for host and TV mode)
            const playersColRef = collection(db, PLAYERS_COLLECTION);
            onSnapshot(playersColRef, (snapshot) => {
                const newPlayers = {};
                let currentUserData = null;
                snapshot.forEach(doc => {
                    const player = doc.data();
                    newPlayers[doc.id] = player;
                    if (doc.id === userId) {
                        currentUserData = player;
                    }
                });
                gameState.players = newPlayers;
                userData = currentUserData;

                // Re-render UI after any data change
                render();
            });

            // 3. Timer Updater (Client-side, only for question phase)
            setInterval(() => {
                if (gameState.status === 'in_progress' && gameState.questionStartTime > 0) {
                    const elapsed = Date.now() - gameState.questionStartTime;
                    const remainingSeconds = Math.max(0, 15 - Math.floor(elapsed / 1000));
                    
                    if (gameState.timer !== remainingSeconds) {
                        gameState.timer = remainingSeconds;
                        // Force a partial re-render only for the timer display if needed (or full render)
                        if (isTVMode) {
                            render(); // Re-render the TV view to update timer
                        }
                    }

                    // Host-side check: if time is up, trigger revealAnswer
                    if (gameState.timer === 0 && gameState.hostId === userId && gameState.status === 'in_progress') {
                        revealAnswer();
                    }
                }
            }, 500);
        }

        async function initializeAppAndAuth() {
            // 1. Check Config
            if (!firebaseConfig) {
                gameContent.innerHTML = `<div class="card p-6 text-center text-xl text-red-500">
                    <h2 class="text-3xl text-creepy-orange mb-4">Configuration Error</h2>
                    <p>Firebase is not configured. This app cannot run.</p>
                </div>`;
                return;
            }

            // 2. Initialize Firebase
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                 gameContent.innerHTML = `<div class="card p-6 text-center text-xl text-red-500">
                    <h2 class="text-3xl text-creepy-orange mb-4">Firebase Error</h2>
                    <p>Could not initialize Firebase services.</p>
                </div>`;
                return;
            }

            // 3. Authenticate User
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    setupListeners(); // Start listening for data
                } else {
                    // Sign in anonymously if no user is found
                    try {
                        // Use the initial auth token if provided by the environment, otherwise sign in anonymously
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                             await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Anonymous Sign-in Failed:", error);
                        userId = generateTemporaryId(); // Fallback ID if auth fails
                        setupListeners();
                    }
                }
            });
        }

        // Start the application
        window.onload = initializeAppAndAuth;

    </script>
</body>
</html>
