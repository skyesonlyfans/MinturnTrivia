<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minturn Halloween Trivia</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://kit.fontawesome.com/a57004f25b.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #ff6600;
            --secondary-color: #800080;
            --background-color: #1a1a1a;
            --text-color: #ffffff;
        }
        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            min-height: 100vh;
            background: linear-gradient(45deg, #1a1a1a, #4a004a, #1a1a1a, #5a2000);
            background-size: 400% 400%;
            animation: gradientBG 25s ease infinite;
        }
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        h1, h2, h3 {
            font-family: 'Creepster', cursive;
        }
        .text-creepy-orange { color: var(--primary-color); }
        .bg-creepy-orange { background-color: var(--primary-color); }
        .text-creepy-purple { color: var(--secondary-color); }
        .bg-creepy-purple { background-color: var(--secondary-color); }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(5px);
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border: 2px solid var(--primary-color);
            animation: fadeIn 0.5s ease-out forwards;
        }

        .btn-menu, .btn-game, .btn-host {
            transition: all 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 0 var(--secondary-color);
        }
        .btn-menu:hover, .btn-game:hover, .btn-host:hover {
            box-shadow: 0 6px 0 var(--secondary-color);
            transform: translateY(-2px) scale(1.02);
        }
        .btn-menu:active, .btn-game:active, .btn-host:active {
            box-shadow: 0 0 0 var(--secondary-color);
            transform: translateY(4px);
        }
        
        .btn-answer {
            transition: all 0.2s ease-in-out;
            transform: scale(1);
            border: 2px solid transparent;
            box-shadow: 0 4px 0px rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
        }
        .btn-answer:hover:not([disabled]) {
            transform: scale(1.02);
            border: 2px solid var(--primary-color);
            box-shadow: 0 8px 0px rgba(0, 0, 0, 0.4);
        }
        .btn-answer[disabled] {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .tv-option-reveal {
            opacity: 0.2;
            transition: all 0.5s ease-out;
        }
        .tv-option-reveal.correct-answer {
            opacity: 1;
            background-color: #10b981 !important;
            transform: scale(1.05);
        }
        
        #timer-bar-container {
            height: 12px;
            background-color: #555;
            border-radius: 6px;
            overflow: hidden;
            width: 100%;
        }
        #timer-bar {
            height: 100%;
            background-color: #ff6600;
            width: 100%;
            transition: width 0.1s linear; /* Make transition fast for smooth updates */
            animation: pulseTimer 1.5s infinite ease-in-out;
        }
        @keyframes pulseTimer {
            0% { filter: brightness(100%); }
            50% { filter: brightness(130%); }
            100% { filter: brightness(100%); }
        }
    </style>
</head>
<body>

    <div id="view-main-menu" class="flex flex-col items-center justify-center min-h-screen p-8 text-center">
        <h3 class="text-2xl text-creepy-purple mb-4">Presented by Skye &lt;3</h3>
        <h1 class="text-7xl sm:text-8xl font-bold mb-12 text-creepy-orange tracking-widest">
            Minturn Halloween Trivia
        </h1>
        <div class="card p-10 w-full max-w-md">
            <!-- <h2 class="text-4xl text-white mb-8">Choose Your Path</h2> --> <!-- Removed as requested -->
            <div class="space-y-6 mt-8">
                <button id="btn-join-game" class="w-full p-5 bg-creepy-orange text-white font-extrabold rounded-lg text-3xl btn-menu">
                    <i class="fas fa-ghost mr-3"></i> Join Game
                </button>
                <button id="btn-host-game" class="w-full p-5 bg-creepy-purple text-white font-extrabold rounded-lg text-3xl btn-menu">
                    <i class="fas fa-tv mr-3"></i> Host / Display
                </button>
            </div>
        </div>
    </div>

    <div id="view-game-wrapper" class="hidden w-full">
        <div id="app" class="flex flex-col items-center p-4 sm:p-8">
            <h1 class="text-6xl sm:text-7xl font-bold mb-4 text-creepy-orange tracking-widest text-center">
                Halloween Trivia
            </h1>

            <div id="game-content" class="w-full max-w-6xl">
                <div id="loading-state" class="card p-6 text-center">
                    <i class="fas fa-ghost fa-spin text-4xl text-creepy-orange mb-4"></i>
                    <p class="text-xl">Checking in...</p>
                </div>
            </div>

            <div id="message-box" class="fixed bottom-4 left-1/2 -translate-x-1/2 card p-3 opacity-0 transition-opacity duration-300 pointer-events-none z-50">
                <p id="message-text" class="text-sm"></p>
            </div>
            
            <button id="leave-game-btn" class="hidden fixed top-4 right-4 bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-full transition duration-150 shadow-lg text-xs z-50">
                <i class="fas fa-sign-out-alt mr-2"></i>Leave Game
            </button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, runTransaction, updateDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');
        
        const firebaseConfig = {
          apiKey: "AIzaSyD2qmDEWrqKERcEQf36THyzYb3ip8TLQf4",
          authDomain: "minturntrivia.firebaseapp.com",
          projectId: "minturntrivia",
          storageBucket: "minturntrivia.firebasestorage.app",
          messagingSenderId: "465699900511",
          appId: "1:465699900511:web:a1b7019bc82a5407881fea",
          measurementId: "G-VEX4W50GEE"
        };
        
        const appId = 'minturn-trivia-app';
        
        let app;
        let db;
        let auth;
        let userId;
        let userData;
        let isTVMode = false;

        const APP_COLLECTION = `artifacts/${appId}/public/data/game-state`;
        const PLAYERS_COLLECTION = `artifacts/${appId}/public/data/players`;
        const GAME_DOC_ID = 'main-game';
        
        const QUESTION_TIME_SECONDS = 20; // Changed to 20 seconds
        const INTERMISSION_TIME_SECONDS = 10;
        
        let gameState = {
            status: 'loading',
            currentQuestion: -1, 
            questions: [],
            hostId: null,
            isPaused: false,
            questionStartTime: 0,
            players: {},
            correctAnswer: null,
            transitionTimeEnd: 0,
        };
        
        let gameLoopInterval = null;
        
        const viewMainMenu = document.getElementById('view-main-menu');
        const viewGameWrapper = document.getElementById('view-game-wrapper');
        const btnJoinGame = document.getElementById('btn-join-game');
        const btnHostGame = document.getElementById('btn-host-game');
        const leaveGameBtn = document.getElementById('leave-game-btn');

        btnJoinGame.onclick = () => {
            isTVMode = false;
            viewMainMenu.classList.add('hidden');
            viewGameWrapper.classList.remove('hidden');
            leaveGameBtn.classList.remove('hidden');
            initializeAppAndAuth();
        };
        
        btnHostGame.onclick = () => {
            isTVMode = true;
            viewMainMenu.classList.add('hidden');
            viewGameWrapper.classList.remove('hidden');
            initializeAppAndAuth();
        };
        
        leaveGameBtn.onclick = async () => {
            if (!userId || !db) return;
            if (confirm("Are you sure you want to leave the game?")) {
                try {
                    const playerDocRef = doc(db, PLAYERS_COLLECTION, userId);
                    await deleteDoc(playerDocRef);
                } catch (e) {
                    console.error("Error leaving game:", e);
                } finally {
                    window.location.reload();
                }
            }
        };

        function showMessage(text, isError = false) {
            const messageBox = document.getElementById('message-box');
            if (!messageBox) return;
            const messageText = document.getElementById('message-text');

            messageText.textContent = text;
            messageBox.style.backgroundColor = isError ? '#ef4444' : '#1f2937';
            messageBox.style.opacity = '1';
            
            setTimeout(() => {
                messageBox.style.opacity = '0';
            }, 3000);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        function pcmToWav(pcm16, sampleRate = 24000) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const dataLength = pcm16.length * (bitsPerSample / 8);
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true); 
            view.setUint16(22, numChannels, true); 
            view.setUint32(24, sampleRate, true); 
            view.setUint32(28, sampleRate * numChannels * (bitsPerSample / 8), true); 
            view.setUint16(32, numChannels * (bitsPerSample / 8), true); 
            view.setUint16(34, bitsPerSample, true); 
            
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcm16[i], true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        async function playTTS(text) {
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Fenrir" } } },
                },
                model: "gemini-2.5-flash-preview-tts"
            };
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

            try {
                const maxRetries = 3;
                let attempt = 0;
                let response;

                while (attempt < maxRetries) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                        if (response.status === 429) {
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw new Error(`API returned status ${response.status}`);
                        }
                    } catch (error) {
                        if (attempt === maxRetries - 1) throw error;
                    }
                    attempt++;
                }
                
                if (!response || !response.ok) throw new Error("TTS API call failed after retries.");

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = sampleRateMatch ? parseInt(sampleRateMatch[1], 10) : 24000;
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();
                }

            } catch (error) {
                console.error("Error generating or playing TTS:", error);
            }
        }
        
        async function fetchQuestions() {
            try {
                // We use a unique query param to bypass potential browser caching of the file
                const response = await fetch(`trivia.json.txt?v=${Date.now()}`);
                if (!response.ok) throw new Error("Trivia file not found or failed to load.");
                const data = await response.json();
                if (!Array.isArray(data) || data.length === 0) {
                     throw new Error("Trivia data is invalid or empty.");
                }
                return data;
            } catch (e) {
                console.error("Failed to load trivia questions:", e);
                showMessage("Could not load questions. Using fallback.", true);
                return [
                    { category: "Fallback", question: "What ancient festival is the origin of Halloween?", options: { "A": "Beltane", "B": "Samhain", "C": "Lughnasadh", "D": "Yule" }, answer: "B" },
                    { category: "Fallback", question: "In the film *Halloween*, what mask does Michael Myers wear?", options: { "A": "Clown", "B": "Shatner", "C": "Hockey", "D": "Ghostface" }, answer: "B" },
                ];
            }
        }

        async function initializeGameData() {
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            
            try {
                // Try to set hostId. If doc doesn't exist, this fails and we go to catch.
                await updateDoc(gameDocRef, { 
                    hostId: userId 
                });
            } catch (e) {
                if (e.code === 'not-found') {
                    // Doc doesn't exist, create it as the host
                    const questions = await fetchQuestions();
                    
                    // Shuffle questions
                    for (let i = questions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }

                    const initialData = {
                        status: 'lobby',
                        currentQuestion: -1,
                        totalQuestions: questions.length,
                        questions: questions, // Storing shuffled questions in Firestore
                        hostId: userId,
                        isPaused: false,
                        questionStartTime: Date.now(),
                        correctAnswer: null,
                        transitionTimeEnd: 0,
                        lastUpdate: Date.now(),
                    };
                    await setDoc(gameDocRef, initialData);
                    showMessage("New Game Created!");
                } else {
                    console.error("Error checking game data:", e);
                }
            }
        }
        
        async function deleteGame() {
            if (gameState.hostId !== userId) {
                showMessage("Only the host can reset the game.", true);
                return;
            }
            if (!confirm('Are you sure you want to delete the entire game and all player data?')) return;

            // Stop the game loop if it's running
            if (gameLoopInterval) {
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
            }
            
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            await deleteDoc(gameDocRef);
            
            // Delete all player documents
            const playerDocsQuery = query(collection(db, PLAYERS_COLLECTION));
            const playerDocsSnapshot = await getDocs(playerDocsQuery);
            const deletePromises = playerDocsSnapshot.docs.map(playerDoc => deleteDoc(playerDoc.ref));
            await Promise.all(deletePromises);
            
            showMessage("Game has been completely deleted. Starting fresh...");
            // Re-initialize game data
            await initializeGameData();
        }

        async function togglePause(shouldPause) {
            if (gameState.hostId !== userId) return;
            
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            await updateDoc(gameDocRef, {
                isPaused: shouldPause,
                // Refresh start time on resume to prevent immediate timeout
                questionStartTime: Date.now(),
                lastUpdate: Date.now(),
            });
            showMessage(shouldPause ? "Game Paused." : "Game Resumed!");
            if (!shouldPause) {
                playTTS("Game resumed.");
            }
        }

        async function joinGame(name, color) {
            if (!userId) { showMessage("Authentication failed.", true); return; }
            
            const playerDocRef = doc(db, PLAYERS_COLLECTION, userId);
            try {
                await setDoc(playerDocRef, {
                    id: userId,
                    name: name,
                    color: color,
                    score: 0,
                    lastAnswer: null,
                    joinedAt: Date.now(),
                }, { merge: true });
                showMessage(`Welcome, ${name}!`);
            } catch (e) {
                console.error("Error joining game: ", e);
                showMessage("Failed to join game.", true);
            }
        }
        
        async function submitAnswer(answerKey) {
            if (gameState.status !== 'question' || !userData || gameState.isPaused) return;
            
            const timeElapsed = Date.now() - gameState.questionStartTime;
            
            // Check if already answered this question
            if (userData.lastAnswer && userData.lastAnswer.questionIndex === gameState.currentQuestion) {
                 showMessage("You've already answered!", true);
                 return;
            }
            
            if (timeElapsed >= QUESTION_TIME_SECONDS * 1000) {
                 showMessage("Too late! Time is up.", true);
                 return;
            }

            const playerDocRef = doc(db, PLAYERS_COLLECTION, userId);
            try {
                await updateDoc(playerDocRef, {
                    lastAnswer: {
                        questionIndex: gameState.currentQuestion,
                        answer: answerKey,
                        timeTaken: timeElapsed,
                    },
                    lastUpdateTime: Date.now(),
                });
                showMessage(`Submitted answer ${answerKey}.`);
            } catch (e) {
                console.error("Error submitting answer: ", e);
                showMessage("Failed to submit answer.", true);
            }
        }
        
        async function calculateAndScore() {
            if (gameState.currentQuestion < 0 || !gameState.questions[gameState.currentQuestion]) {
                console.error("Invalid question index for scoring.");
                return;
            }
            
            const currentQ = gameState.questions[gameState.currentQuestion];
            const correctKey = currentQ.answer;

            const playerDocsQuery = query(collection(db, PLAYERS_COLLECTION));
            const playerDocsSnapshot = await getDocs(playerDocsQuery);

            const maxTimeMs = QUESTION_TIME_SECONDS * 1000;

            for (const playerDoc of playerDocsSnapshot.docs) {
                const playerId = playerDoc.id;
                const playerDocRef = doc(db, PLAYERS_COLLECTION, playerId);
                const player = gameState.players[playerId]; // Get data from our local state
                const playerAnswer = player?.lastAnswer;
                
                // Score only if they answered the *current* question and haven't been scored yet
                if (playerAnswer && 
                    playerAnswer.questionIndex === gameState.currentQuestion && 
                    playerAnswer.pointsAwarded === undefined // Check if 'pointsAwarded' is not set
                    ) {
                    
                    await runTransaction(db, async (transaction) => {
                        const freshDoc = await transaction.get(playerDocRef);
                        if (!freshDoc.exists()) return;

                        let currentScore = freshDoc.data().score || 0;
                        let scoreDelta = 0;

                        if (playerAnswer.answer === correctKey) {
                            // Calculate score based on time
                            const timeTaken = Math.min(playerAnswer.timeTaken, maxTimeMs);
                            const timeRatio = 1 - (timeTaken / maxTimeMs); // 1.0 (fastest) to 0.0 (slowest)
                            // Base 500 points + 500 points based on speed
                            scoreDelta = 500 + Math.round(timeRatio * 500); 
                        }

                        // Update the lastAnswer object to mark it as scored
                        transaction.update(playerDocRef, {
                            score: currentScore + scoreDelta,
                            lastAnswer: {...playerAnswer, pointsAwarded: scoreDelta},
                        });
                    });
                }
            }
        }

        let gameContent = document.getElementById('game-content');

        async function hostGameLoop() {
            // Only run if this client is the host, in TV mode, and not paused
            if (!db || gameState.hostId !== userId || gameState.isPaused || document.hidden) return;

            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            const now = Date.now();
            let updatePayload = { lastUpdate: now };
            let shouldUpdate = false;
            
            switch (gameState.status) {
                case 'question':
                    const timeElapsed = now - gameState.questionStartTime;
                    
                    // Time's up for the question
                    if (timeElapsed >= QUESTION_TIME_SECONDS * 1000) {
                        const currentQ = gameState.questions[gameState.currentQuestion];
                        updatePayload.status = 'reveal';
                        updatePayload.correctAnswer = currentQ.answer;
                        updatePayload.questionStartTime = now; // Reset timer for the reveal phase
                        updatePayload.transitionTimeEnd = now + INTERMISSION_TIME_SECONDS * 1000;
                        shouldUpdate = true;
                        
                        // Calculate scores before revealing
                        await calculateAndScore();
                        playTTS(`Time is up! The correct answer is ${currentQ.answer}`);
                    }
                    break;

                case 'reveal':
                    // Time's up for the answer reveal
                    if (now >= gameState.transitionTimeEnd) {
                        const nextQuestionIndex = gameState.currentQuestion + 1;
                        
                        if (nextQuestionIndex < gameState.totalQuestions) {
                            // Move to intermission (scoreboard)
                            updatePayload.status = 'intermission';
                            updatePayload.questionStartTime = now;
                            updatePayload.transitionTimeEnd = now + 5000; // 5-second scoreboard
                            shouldUpdate = true;
                            playTTS("Here are the current scores before the next round.");
                        } else {
                            // Game over
                            updatePayload.status = 'finished';
                            updatePayload.currentQuestion = -1; // Reset question index
                            updatePayload.questionStartTime = now;
                            shouldUpdate = true;
                            playTTS("The game is over! Let's see the final scores.");
                        }
                    }
                    break;
                    
                case 'intermission':
                    // Time's up for the scoreboard
                    if (now >= gameState.transitionTimeEnd) {
                        const nextQuestionIndex = gameState.currentQuestion + 1;
                        
                        if (nextQuestionIndex < gameState.totalQuestions) {
                            // Move to the next question
                            updatePayload.status = 'question';
                            updatePayload.currentQuestion = nextQuestionIndex;
                            updatePayload.questionStartTime = now;
                            updatePayload.correctAnswer = null; // Clear correct answer
                            updatePayload.transitionTimeEnd = 0;
                            shouldUpdate = true;
                            playTTS(`Question number ${nextQuestionIndex + 1}!`);
                        }
                    }
                    break;
                    
                case 'lobby':
                case 'finished':
                    // Do nothing, wait for host to start/delete
                    break;
            }

            if (shouldUpdate) {
                try {
                    await updateDoc(gameDocRef, updatePayload);
                } catch (e) {
                    console.error("Host loop update failed:", e);
                }
            }
        }
        
        function startGame() {
            if (gameState.hostId !== userId || gameState.status !== 'lobby') return;
            if (Object.keys(gameState.players).length < 1) {
                showMessage("Need at least one player to start!", true);
                return;
            }
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            updateDoc(gameDocRef, {
                status: 'question',
                currentQuestion: 0,
                questionStartTime: Date.now(),
                isPaused: false,
                correctAnswer: null,
                lastUpdate: Date.now(),
                transitionTimeEnd: 0,
            }).then(() => {
                showMessage("Game started!");
                playTTS("Welcome to the Halloween Trivia Showdown! Question number one!");
            }).catch(e => {
                console.error("Error starting game:", e);
                showMessage("Failed to start game.", true);
            });
        }
        
        function startHostLoop() {
            // Ensure only one loop is running
            if (isTVMode && gameState.hostId === userId && !gameLoopInterval) {
                gameLoopInterval = setInterval(hostGameLoop, 1000);
            }
        }

        function render() {
            let view = 'loading';
            if (!userId) {
                view = 'loading';
            } else if (gameState.status === 'lobby' && !userData && !isTVMode) {
                view = 'join';
            } else if (gameState.status === 'lobby') {
                view = 'lobby';
            } else if (gameState.status === 'question') {
                view = 'question';
            } else if (gameState.status === 'reveal') {
                view = 'reveal';
            } else if (gameState.status === 'intermission') {
                view = 'scoreboard';
            } else if (gameState.status === 'finished') {
                view = 'scoreboard';
            }

            if (isTVMode) {
                renderTVView(view);
            } else {
                renderPlayerView(view);
            }
        }
        
        function renderPlayerView(view) {
            switch (view) {
                case 'join':
                    // *** BUGFIX ***
                    // Only render the join form if it doesn't already exist.
                    // This prevents re-rendering and losing input focus.
                    if (!document.getElementById('join-form')) {
                        renderJoinForm();
                    }
                    break;
                case 'lobby':
                    renderLobbyPlayer();
                    break;
                case 'question':
                    renderQuestionPlayer();
                    break;
                case 'reveal':
                case 'intermission':
                    renderScoringPlayer();
                    break;
                case 'scoreboard':
                case 'finished':
                    renderScoreboardPlayer();
                    break;
                case 'loading':
                default:
                    gameContent.innerHTML = `<div class="card p-6 text-center">
                        <i class="fas fa-ghost fa-spin text-4xl text-creepy-orange mb-4"></i>
                        <p class="text-xl">Checking in...</p>
                    </div>`;
            }
        }
        
        function renderJoinForm() {
            // Player colors
            let colors = ['#e91e63', '#9c27b0', '#ff6600', '#ffffff', '#9e9e9e', '#795548', '#4caf50', '#ffeb3b'];
            let selectedColor = colors[0];

            function colorSelectorHTML() {
                return colors.map(c => `
                    <button type="button" data-color="${c}" style="background-color: ${c}; border-color: ${(c === '#ffffff' || c === '#ffeb3b') ? '#444' : 'transparent'};" 
                        class="color-btn w-10 h-10 rounded-full mx-1 shadow-lg border-2 ${c === selectedColor ? 'border-white ring-2 ring-creepy-orange' : 'border-gray-500'}"
                        onclick="window.selectColor('${c}')"></button>
                `).join('');
            }
            
            window.selectColor = (c) => {
                selectedColor = c;
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.classList.remove('border-white', 'ring-2', 'ring-creepy-orange');
                    if (btn.dataset.color === c) {
                        btn.classList.add('border-white', 'ring-2', 'ring-creepy-orange');
                    }
                });
            };

            const html = `
                <div class="card p-8 w-full max-w-md mx-auto mt-10">
                    <h2 class="text-3xl text-creepy-orange mb-6 text-center">Join the Fray</h2>
                    <form id="join-form" class="space-y-4">
                        <div>
                            <label for="player-name" class="block text-sm font-semibold mb-1">Nickname:</label>
                            <input type="text" id="player-name" placeholder="Enter your name" required maxlength="15"
                                class="w-full p-3 rounded bg-gray-700 text-white border border-gray-600 focus:border-creepy-orange focus:ring-1 focus:ring-creepy-orange">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold mb-2">Pick Your Color:</label>
                            <div class="flex flex-wrap justify-center" id="color-picker-container">
                                ${colorSelectorHTML()}
                            </div>
                        </div>
                        <button type="submit" 
                            class="w-full p-3 mt-6 bg-creepy-orange hover:bg-opacity-90 text-white font-extrabold rounded-lg text-lg btn-game">
                            Enter Game
                        </button>
                    </form>
                </div>
            `;
            gameContent.innerHTML = html;
            
            // Attach listener
            document.getElementById('join-form').onsubmit = (e) => {
                e.preventDefault();
                const name = document.getElementById('player-name').value.trim();
                if (name) {
                    joinGame(name, selectedColor);
                }
            };
        }

        function renderLobbyPlayer() {
            const playerCount = Object.keys(gameState.players).length;
            const html = `
                <div class="card p-8 w-full max-w-xl mx-auto mt-10 text-center">
                    <h2 class="text-4xl text-creepy-purple mb-4">Lobby Waiting...</h2>
                    <p class="mb-8 text-gray-400">Welcome, <span style="color:${userData?.color || '#fff'}; font-weight:bold;">${userData?.name || 'Player'}</span>!</p>
                    <p class="text-xl text-gray-300 animate-pulse mb-4">Waiting for the Host to start...</p>
                    <p class="text-3xl font-extrabold text-creepy-orange">${playerCount} Players Ready</p>
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderQuestionPlayer() {
            const questionIndex = gameState.currentQuestion;
            if (questionIndex < 0 || !gameState.questions[questionIndex]) return;
            const currentQ = gameState.questions[questionIndex];

            const isAnswered = userData?.lastAnswer?.questionIndex === questionIndex;
            const answeredKey = isAnswered ? userData.lastAnswer.answer : null;
            
            const optionsMap = { A: 'bg-red-700', B: 'bg-blue-700', C: 'bg-yellow-700', D: 'bg-green-700' };

            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                let classes = `${optionsMap[key] || 'bg-gray-700'} rounded-xl font-bold w-full text-center btn-answer flex items-center space-x-4`;
                if (answeredKey === key) {
                    classes += ' selected ring-4 ring-creepy-orange';
                }
                
                return `
                    <button onclick="window.submitAnswer('${key}')" ${isAnswered ? 'disabled' : ''}
                        class="${classes}">
                        <span class="flex-shrink-0 w-12 h-12 flex items-center justify-center bg-black/20 rounded-lg text-2xl font-black">${key}</span>
                        <span class="text-left text-xl">${value}</span>
                    </button>
                `;
            }).join('');

            const html = `
                <div class="card p-6 mt-4">
                    <div class="flex justify-between items-center mb-6 border-b border-gray-700 pb-3">
                        <p class="text-lg text-creepy-purple font-semibold">Q${questionIndex + 1} / ${gameState.totalQuestions}</p>
                        <p class="text-lg text-gray-400">Category: ${currentQ.category}</p>
                    </div>
                    
                    <h2 class="text-4xl font-extrabold mb-8 text-center text-gray-200">${currentQ.question}</h2>
                    
                    <div id="answer-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${optionsHTML}
                    </div>
                    
                    <div class="mt-8 text-center">
                        <p class="text-xl text-gray-400">
                            ${isAnswered ? 
                                `<span class="text-green-400 font-bold"><i class="fas fa-check-circle mr-2"></i>Answer Locked In!</span>` : 
                                'Choose your answer!'}
                        </p>
                    </div>
                </div>
            `;
            gameContent.innerHTML = html;
            window.submitAnswer = submitAnswer;
        }

        function renderScoringPlayer() {
            const questionIndex = gameState.currentQuestion;
            if (questionIndex < 0 || !gameState.questions[questionIndex]) return;
            const currentQ = gameState.questions[questionIndex];
            const correctKey = gameState.correctAnswer;
            const playerAnswer = userData?.lastAnswer;
            
            // Check if the last answer matches the current question
            const isRelevantAnswer = playerAnswer?.questionIndex === questionIndex;
            const isAnsweredCorrectly = isRelevantAnswer && playerAnswer?.answer === correctKey;
            const points = isRelevantAnswer ? (playerAnswer?.pointsAwarded || 0) : 0;
            const answeredKey = isRelevantAnswer ? playerAnswer?.answer : null;

            const feedbackTitle = isAnsweredCorrectly ? 
                `<h3 class="text-4xl text-green-400 font-extrabold"><i class="fas fa-bolt mr-2"></i>CORRECT! +${points}</h3>` :
                `<h3 class="text-4xl text-red-400 font-extrabold"><i class="fas fa-skull-crossbones mr-2"></i>INCORRECT!</h3>`;
            
            const optionsMap = { A: 'bg-red-700', B: 'bg-blue-700', C: 'bg-yellow-700', D: 'bg-green-700' };
            
            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                let classes = `${optionsMap[key] || 'bg-gray-700'} p-4 rounded-xl text-xl font-bold w-full text-center opacity-60 flex items-center space-x-4`;
                let icon = '';

                if (key === correctKey) {
                    classes = 'bg-green-600 p-4 rounded-xl text-xl font-bold w-full text-center ring-4 ring-green-400 opacity-100 flex items-center space-x-4';
                    icon = '<i class="fas fa-check ml-auto"></i>';
                } else if (key === answeredKey) {
                    // Highlight player's wrong answer
                    classes = 'bg-red-600 p-4 rounded-xl text-xl font-bold w-full text-center ring-4 ring-red-400 opacity-100 flex items-center space-x-4';
                    icon = '<i class="fas fa-times ml-auto"></i>';
                }
                
                return `<div class="${classes}">
                            <span class="flex-shrink-0 w-12 h-12 flex items-center justify-center bg-black/20 rounded-lg text-2xl font-black">${key}</span>
                            <span class="text-left text-xl">${value}</span>
                            ${icon}
                        </div>`;
            }).join('');

            const html = `
                <div class="card p-6 mt-4 text-center">
                    <h2 class="text-4xl font-extrabold mb-4 text-gray-200">${currentQ.question}</h2>
                    
                    <div class="mb-6 p-4 rounded-xl shadow-inner ${isAnsweredCorrectly ? 'bg-green-900/40' : 'bg-red-900/40'}">
                        ${feedbackTitle}
                        <p class="text-xl mt-2">Total Score: <span class="font-bold text-creepy-orange">${userData?.score || 0}</span></p>
                    </div>

                    <div id="answer-options" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${optionsHTML}
                    </div>
                    
                    <p class="mt-6 text-xl text-gray-400 animate-pulse">Waiting for the Host to proceed...</p>
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderScoreboardPlayer() {
             const sortedPlayers = Object.values(gameState.players).sort((a, b) => b.score - a.score);
             const isFinal = gameState.status === 'finished';

             const playerRankings = sortedPlayers.map((p, index) => {
                 let medalIcon = '';
                 if (index === 0) medalIcon = '<i class="fas fa-trophy text-yellow-500 text-3xl"></i>';
                 if (index === 1) medalIcon = '<i class="fas fa-medal text-gray-400 text-2xl"></i>';
                 if (index === 2) medalIcon = '<i class="fas fa-medal text-yellow-700 text-xl"></i>';

                 const highlightClass = p.id === userId ? 'ring-4 ring-creepy-orange bg-gray-600/50' : 'bg-gray-700/50';

                 return `
                    <li class="flex justify-between items-center p-4 rounded-xl my-2 shadow-xl ${highlightClass} transition duration-300 transform hover:scale-[1.01]">
                        <div class="flex items-center space-x-3">
                            <span class="text-2xl font-black w-8 text-center text-gray-300">${index + 1}</span>
                            <span class="text-3xl mr-2 w-8 text-center" style="color:${p.color};">${medalIcon}</span>
                            <span class="text-xl font-bold" style="color:${p.color};">${p.name}</span>
                        </div>
                        <span class="text-2xl font-extrabold text-creepy-orange">${p.score} <span class="text-sm font-normal text-gray-400">PTS</span></span>
                    </li>
                 `;
             }).join('');
             
            const html = `
                <div class="card p-8 w-full max-w-xl mx-auto mt-4 text-center">
                    <h2 class="text-5xl ${isFinal ? 'text-creepy-orange' : 'text-creepy-purple'} mb-4">${isFinal ? 'Final Scoreboard' : 'Leaderboard'}</h2>
                    ${isFinal && sortedPlayers.length > 0 ? 
                        `<p class="text-2xl text-yellow-500 font-extrabold mb-6">🏆 ${sortedPlayers[0].name} Wins! 🏆</p>` : ''}
                    
                    <ul class="text-left max-h-[80vh] overflow-y-auto">
                        ${playerRankings || '<li class="text-center text-gray-500 p-4">Waiting for scores...</li>'}
                    </ul>
                    
                    ${!isFinal ? '<p class="mt-8 text-lg text-gray-400 animate-pulse">Waiting for Host to continue...</p>' : ''}
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderTVView(view) {
            const isHost = gameState.hostId === userId;
            // Ensure the host loop is started if this user is the host
            startHostLoop();

            switch (view) {
                case 'lobby':
                case 'finished':
                    renderLobbyOrFinalTV(view);
                    break;
                case 'question':
                case 'reveal':
                case 'intermission':
                    renderGameScreenTV(view);
                    break;
                default:
                    gameContent.innerHTML = `<div class="card p-6 text-center text-2xl">Initializing Host and Game...</div>`;
            }
        }
        
        function getHostControls(isHost) {
            if (!isHost) return '';

            const pauseBtn = gameState.isPaused ? 
                `<button onclick="window.togglePause(false)" class="bg-green-500 hover:bg-green-600 text-white p-3 rounded-xl font-bold transition-all btn-host shadow-green-700/50">
                    <i class="fas fa-play mr-2"></i> RESUME GAME
                </button>` :
                `<button onclick="window.togglePause(true)" class="bg-yellow-500 hover:bg-yellow-600 text-black p-3 rounded-xl font-bold transition-all btn-host shadow-yellow-700/50">
                    <i class="fas fa-pause mr-2"></i> PAUSE GAME
                </button>`;

            const deleteBtn = `<button onclick="window.deleteGame()" class="bg-red-500 hover:bg-red-600 text-white p-3 rounded-xl font-bold transition-all btn-host shadow-red-700/50">
                <i class="fas fa-trash mr-2"></i> DELETE GAME
            </button>`;
            
            // Only show pause/resume if game is in progress
            const showPause = gameState.status === 'question' || gameState.status === 'reveal' || gameState.status === 'intermission';

            return `
                <div class="mt-6 p-4 bg-gray-800 rounded-xl shadow-lg border border-gray-700">
                    <h3 class="text-sm font-semibold text-gray-400 mb-2">HOST CONTROLS</h3>
                    <div class="flex flex-wrap justify-center gap-3">
                        ${showPause ? pauseBtn : ''}
                        ${deleteBtn}
                    </div>
                    ${gameState.isPaused ? '<p class="text-sm text-yellow-400 mt-2">Game is paused. Automated transitions are halted.</p>' : ''}
                </div>
            `;
        }

        function renderLobbyOrFinalTV(view) {
            const isHost = gameState.hostId === userId;
            const playerCount = Object.keys(gameState.players).length;
            const sortedPlayers = Object.values(gameState.players).sort((a, b) => b.score - a.score);
            const isFinal = view === 'finished';
            // Use the base URL without any query params for the join link
            const appUrl = window.location.origin + window.location.pathname;
            
            let mainContent = '';

            if (isFinal) {
                mainContent = `
                    <h2 class="text-7xl text-creepy-orange mb-4">FINAL RESULTS</h2>
                    <p class="text-3xl text-yellow-500 font-extrabold mb-8">🏆 ${sortedPlayers[0]?.name || 'No One'} Wins! 🏆</p>
                    <ul class="text-left max-h-[40vh] overflow-y-auto w-full space-y-3">
                        ${sortedPlayers.slice(0, 10).map((p, index) => `
                            <li class="flex justify-between items-center p-4 rounded-xl bg-gray-700/50">
                                <span class="text-3xl font-black w-10 text-creepy-orange">${index + 1}</span>
                                <span class="text-3xl font-bold flex-grow" style="color:${p.color};">${p.name}</span>
                                <span class="text-4xl font-extrabold text-creepy-orange">${p.score}</span>
                            </li>
                        `).join('')}
                    </ul>
                    <div class="mt-10">
                        ${isHost ? `<p class="text-xl text-gray-400">Press DELETE GAME to clear data and start a new lobby.</p>` : ''}
                    </div>
                `;
            } else {
                const playersList = Object.values(gameState.players)
                    .map(p => `<li class="p-2 text-xl font-semibold rounded-lg bg-gray-700/50 my-1 shadow" style="color:${p.color};">${p.name}</li>`)
                    .join('');

                mainContent = `
                    <h2 class="text-6xl text-creepy-orange mb-6">Join the Game!</h2>
                    <div class="bg-white p-4 inline-block rounded-xl shadow-2xl">
                        <img src="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(appUrl)}" alt="QR Code" class="w-48 h-48"/>
                    </div>
                    <p class="mt-4 text-xl text-gray-300 font-semibold">
                        Scan or Go to: <span class="text-creepy-purple font-mono text-lg">${appUrl}</span>
                    </p>
                    <h3 class="text-3xl text-creepy-purple font-bold mt-8 mb-4">${playerCount} Players Ready!</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-3 max-h-48 overflow-y-auto">
                        ${playersList || '<div class="col-span-4 text-gray-500 p-4">No players yet. Scan the code to join!</div>'}
                    </div>
                    ${isHost ? `
                        <button onclick="window.startGame()" 
                            class="w-full p-4 mt-8 bg-green-500 hover:bg-green-600 text-white font-extrabold rounded-lg text-3xl btn-game shadow-green-700/50">
                            <i class="fas fa-bomb mr-3"></i> START TRIVIA!
                        </button>
                    ` : '<p class="mt-6 text-xl animate-pulse">Initializing Host...</p>'}
                `;
            }

            const html = `
                <div class="card p-10 w-full mx-auto mt-4 text-center">
                    ${mainContent}
                    ${getHostControls(isHost)}
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderGameScreenTV(view) {
            const isHost = gameState.hostId === userId;
            const questionIndex = gameState.currentQuestion;
            
            const isIntermission = view === 'intermission';
            
            if (isIntermission) {
                renderScoreboardTV(isHost);
                return;
            }

            // Check for valid question
            if (questionIndex < 0 || !gameState.questions[questionIndex]) {
                 gameContent.innerHTML = `<div class="card p-6 text-center text-2xl">Loading next question...</div>`;
                 return;
            }
            const currentQ = gameState.questions[questionIndex];
            const isReveal = view === 'reveal';

            // Calculate initial time for render
            const timeElapsed = Date.now() - gameState.questionStartTime;
            const timeRemaining = isReveal ? 0 : Math.max(0, QUESTION_TIME_SECONDS - Math.floor(timeElapsed / 1000));
            const timerPercent = isReveal ? 0 : Math.max(0, 100 - (timeElapsed / (QUESTION_TIME_SECONDS * 1000)) * 100);
            
            // Tally answers
            const answerTally = { 'A': 0, 'B': 0, 'C': 0, 'D': 0 };
            let totalAnswered = 0;
            Object.values(gameState.players).forEach(p => {
                if (p.lastAnswer && p.lastAnswer.questionIndex === questionIndex) {
                    answerTally[p.lastAnswer.answer]++;
                    totalAnswered++;
                }
            });
            const playerCount = Object.keys(gameState.players).length;
            const totalWidth = isReveal ? Math.max(1, totalAnswered) : playerCount; // Avoid division by zero

            const optionsMap = { A: 'bg-red-700', B: 'bg-blue-700', C: 'bg-yellow-700', D: 'bg-green-700' };

            const optionsHTML = Object.entries(currentQ.options).map(([key, value]) => {
                const isCorrect = isReveal && key === gameState.correctAnswer;
                const backgroundColor = optionsMap[key] || 'bg-gray-700';
                const tallyCount = answerTally[key] || 0;
                const barWidth = totalWidth > 0 ? (tallyCount / totalWidth) * 100 : 0;
                const revealClass = isReveal ? 'tv-option-reveal ' + (isCorrect ? 'correct-answer' : '') : '';

                return `
                    <div class="${backgroundColor} p-4 rounded-xl text-lg font-bold w-full text-center shadow-lg relative overflow-hidden ${revealClass}">
                        <div class="absolute inset-0 bg-white/20 transition-all duration-500" style="width: ${isReveal ? barWidth : 0}%"></div>
                        <div class="relative z-10 flex flex-col items-center">
                            <span class="inline-block w-10 h-10 flex items-center justify-center bg-black/20 rounded-lg text-2xl font-black mb-2">${key}</span>
                            <span class="text-2xl">${value}</span>
                            ${isReveal ? `
                                <div class="mt-3 text-3xl font-black text-creepy-orange">
                                    ${tallyCount} <span class="text-sm text-gray-300">VOTES</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            const timerDisplay = isReveal ? 
                `<span class="text-4xl text-green-400 font-extrabold"><i class="fas fa-check-circle"></i> ANSWER REVEALED!</span>` : 
                `<span id="tv-timer-text" class="text-6xl font-extrabold text-creepy-orange">${timeRemaining}</span>`;

            const html = `
                <div class="card p-10 mt-4">
                    <div class="flex justify-between items-center mb-6 pb-2 border-b-4 border-creepy-purple">
                        <p class="text-3xl text-creepy-purple font-extrabold">Q${questionIndex + 1} / ${gameState.totalQuestions}</p>
                        ${timerDisplay}
                        <p class="text-3xl text-gray-400 font-extrabold">${currentQ.category}</p>
                    </div>

                    ${!isReveal ? `<div id="timer-bar-container" class="mb-6"><div id="timer-bar" style="width: ${timerPercent}%;"></div></div>` : ''}
                    
                    <h2 class="text-5xl font-extrabold mb-10 text-center">${currentQ.question}</h2>
                    
                    <div id="answer-options" class="grid grid-cols-2 gap-6">
                        ${optionsHTML}
                    </div>
                    
                    <div class="mt-8 text-center text-2xl text-gray-400">
                        ${isReveal ? 
                            `Next Intermission in: ${Math.max(0, Math.ceil((gameState.transitionTimeEnd - Date.now()) / 1000))}s` :
                            `Players Answered: <span class="text-creepy-orange font-bold">${totalAnswered}/${playerCount}</span>`
                        }
                    </div>

                    ${getHostControls(isHost)}
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function renderScoreboardTV(isHost) {
             const sortedPlayers = Object.values(gameState.players).sort((a, b) => b.score - a.score);
             const isFinal = gameState.status === 'finished';
             const isIntermission = gameState.status === 'intermission';
             
             let countdown = 0;
             if (isIntermission) {
                countdown = Math.max(0, Math.ceil((gameState.transitionTimeEnd - Date.now()) / 1000));
             }

             const playerRankings = sortedPlayers.map((p, index) => {
                 let medalIcon = '';
                 if (index === 0) medalIcon = '<i class="fas fa-crown text-yellow-500 text-5xl"></i>';

                 return `
                    <li class="flex justify-between items-center p-5 rounded-xl my-2 shadow-2xl bg-gray-700/50 hover:scale-[1.01] transition-transform duration-300">
                        <div class="flex items-center space-x-4">
                            <span class="text-4xl font-black w-10 text-creepy-orange text-center">${index + 1}</span>
                            <span class="text-4xl w-10 text-center" style="color:${p.color};">${medalIcon}</span>
                            <span class="text-3xl font-bold" style="color:${p.color};">${p.name}</span>
                        </div>
                        <span class="text-4xl font-extrabold text-creepy-orange">${p.score} <span class="text-lg font-normal text-gray-400">PTS</span></span>
                    </li>
                 `;
             }).join('');
             
            const html = `
                <div class="card p-10 w-full mx-auto mt-4 text-center">
                    <h2 class="text-7xl ${isFinal ? 'text-creepy-orange' : 'text-creepy-purple'} mb-4">${isFinal ? 'FINAL SCOREBOARD' : 'LEADERBOARD'}</h2>
                    
                    ${isFinal && sortedPlayers.length > 0 ? 
                        `<p class="text-3xl text-yellow-500 font-extrabold mb-8">🏆 THE WINNER IS ${sortedPlayers[0].name.toUpperCase()}! 🏆</p>` : ''}
                    
                    <ul class="text-left max-h-[60vh] overflow-y-auto">
                        ${playerRankings || '<li class="text-center text-gray-500 p-4">No scores to display.</li>'}
                    </ul>
                    
                    ${isIntermission ? `
                        <p class="text-3xl text-green-400 font-extrabold mt-8 animate-pulse">Next Question in... ${countdown}s</p>
                    ` : ''}

                    ${getHostControls(isHost)}
                </div>
            `;
            gameContent.innerHTML = html;
        }

        function setupListeners() {
            // Listener for the main game document
            const gameDocRef = doc(db, APP_COLLECTION, GAME_DOC_ID);
            onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const oldStatus = gameState.status;
                    gameState = { ...gameState, ...docSnap.data() };
                    
                    // If we just entered a new question state, play TTS
                    if(oldStatus !== 'question' && gameState.status === 'question' && isTVMode) {
                        const qIndex = gameState.currentQuestion;
                        if(qIndex >= 0 && gameState.questions[qIndex]) {
                            playTTS(`Question ${qIndex + 1}. ${gameState.questions[qIndex].question}`);
                        }
                    }
                } else if (userId && isTVMode) {
                    // If doc is deleted (e.g., by host) and this is the host, re-initialize
                    initializeGameData().catch(e => console.error("Failed to re-initialize game:", e));
                }
                render();
            });
            
            // Listener for the players collection
            const playersColRef = collection(db, PLAYERS_COLLECTION);
            onSnapshot(playersColRef, (snapshot) => {
                const newPlayers = {};
                let currentUserData = null;
                snapshot.forEach(doc => {
                    const player = doc.data();
                    newPlayers[doc.id] = player;
                    if (doc.id === userId) {
                        currentUserData = player;
                    }
                });
                gameState.players = newPlayers;
                userData = currentUserData;
                render();
            });
        }

        async function initializeAppAndAuth() {
            if (!firebaseConfig.projectId) {
                showMessage("Firebase config missing.", true);
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                return;
            }

            // Smooth timer interval for TV mode
            if (isTVMode) {
                setInterval(() => {
                    if (gameState.status === 'question' && !gameState.isPaused) {
                        const timerText = document.getElementById('tv-timer-text');
                        const timerBar = document.getElementById('timer-bar');
                        if (timerText && timerBar) {
                            const timeElapsed = Date.now() - gameState.questionStartTime;
                            const timeRemaining = Math.max(0, QUESTION_TIME_SECONDS - Math.floor(timeElapsed / 1000));
                            const timerPercent = Math.max(0, 100 - (timeElapsed / (QUESTION_TIME_SECONDS * 1000)) * 100);
                            
                            timerText.textContent = timeRemaining;
                            timerBar.style.width = `${timerPercent}%`;
                        }
                    }
                }, 100); // Update 10 times a second
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    
                    if (isTVMode) {
                        // This client is a host, it must assert its host status
                        await initializeGameData(); 
                    }
                    
                    // Auth is ready, set up listeners
                    setupListeners();
                    // Call render once auth is complete to move from "Checking in"
                    render();
                } else {
                    // No user, sign in anonymously
                    try {
                         await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Anonymous Authentication Failed:", error);
                        showMessage("Failed to sign in. Live features disabled.", true);
                    }
                }
            });
        }

        // Make key functions globally accessible for inline HTML onClicks
        window.togglePause = togglePause;
        window.deleteGame = deleteGame;
        window.startGame = startGame;
        window.submitAnswer = submitAnswer;
        // window.selectColor is attached inside renderJoinForm

    </script>
</body>
</html>

